<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jonas Otto" />
  <meta name="dcterms.date" content="2023-01-01" />
  <title>Architectures for Distributed Internet Services</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="styling.css" />
  <script src="/usr/share/javascript/mathjax/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Architectures for Distributed Internet Services</h1>
<p class="author">Jonas Otto</p>
<p class="date">2023</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#architectures-for-distributed-internet-services">Architectures for Distributed Internet Services</a></li>
<li><a href="#static-web-content">Static Web Content</a>
<ul>
<li><a href="#web-servers">Web Servers</a>
<ul>
<li><a href="#static-content">Static Content</a></li>
<li><a href="#architectures">Architectures</a></li>
</ul></li>
</ul></li>
<li><a href="#dynamic-web-content">Dynamic Web Content</a>
<ul>
<li><a href="#client-side-dynamicity">Client-side dynamicity</a></li>
<li><a href="#server-side-dynamicity">Server-side dynamicity</a></li>
<li><a href="#creating-dynamic-web-content">Creating dynamic web content</a>
<ul>
<li><a href="#server-side-includes">Server Side Includes</a></li>
<li><a href="#external-programs-cgi">External Programs: CGI</a></li>
<li><a href="#alternative-fastcgi">Alternative: FastCGI</a></li>
<li><a href="#scgi-simple-common-gateway-interface-alternative-to-fastcgi">SCGI (Simple Common Gateway Interface): Alternative to FastCGI</a></li>
<li><a href="#problems-with-cgi">Problems with CGI</a></li>
</ul></li>
</ul></li>
<li><a href="#server-side-scripting">Server-side Scripting</a>
<ul>
<li><a href="#example-perl">Example: Perl</a></li>
<li><a href="#example-java">Example: Java</a></li>
<li><a href="#example-php">Example: PHP</a></li>
</ul></li>
<li><a href="#data-management-sever-side-state">Data Management: Sever-Side State</a>
<ul>
<li><a href="#storage-options">Storage Options</a>
<ul>
<li><a href="#main-memory">main memory</a></li>
<li><a href="#local-storage">local storage</a></li>
<li><a href="#remote-storage">remote storage</a></li>
</ul></li>
</ul></li>
<li><a href="#session-management">Session Management</a>
<ul>
<li><a href="#url-session-identifiers">URL Session Identifiers</a></li>
<li><a href="#cookies">Cookies</a></li>
<li><a href="#session-state">Session State</a></li>
<li><a href="#securtity">Securtity</a></li>
</ul></li>
<li><a href="#client-side-developments">Client-side Developments</a></li>
<li><a href="#object-relational-mapping">Object-Relational Mapping</a></li>
<li><a href="#structured-developments">Structured Developments</a>
<ul>
<li><a href="#mvc">MVC</a>
<ul>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#some-more-structural-patterns">Some more structural patterns</a>
<ul>
<li><a href="#inversion-of-control-ioc">Inversion of Control (IoC)</a></li>
<li><a href="#dont-repeat-yourself">Don’t Repeat Yourself</a></li>
<li><a href="#convention-over-configuration">Convention Over Configuration</a></li>
<li><a href="#structured-project-directories">Structured Project Directories</a></li>
</ul></li>
</ul></li>
<li><a href="#ria-and-spa">RIA and SPA</a>
<ul>
<li><a href="#thin-vs.-thick-clients">Thin vs. Thick Clients</a></li>
<li><a href="#rich-internet-applications-ria">Rich Internet Applications (RIA)</a></li>
<li><a href="#single-page-applications-spa">Single Page Applications (SPA)</a></li>
</ul></li>
<li><a href="#node.js-and-unification-of-languages">Node.js and Unification of Languages</a>
<ul>
<li><a href="#emerging-challenges">Emerging Challenges</a></li>
<li><a href="#event-driven-web-application-runtime">Event-driven Web Application Runtime</a></li>
<li><a href="#node.js">Node.js</a></li>
<li><a href="#unification-of-languages">Unification of Languages</a></li>
</ul></li>
<li><a href="#component-based-frameworks">Component-based Frameworks</a>
<ul>
<li><a href="#web-components-specification">Web Components Specification</a></li>
<li><a href="#component-based-application-frameworks">Component-based Application Frameworks</a></li>
</ul></li>
<li><a href="#progressive-web-applications">Progressive Web Applications</a></li>
<li><a href="#popular-implementations">Popular Implementations</a></li>
<li><a href="#introduction-to-scalability">Introduction to Scalability</a>
<ul>
<li><a href="#part-1">Part 1</a>
<ul>
<li><a href="#client-side-performance-metrics">Client Side Performance Metrics</a></li>
<li><a href="#server-side-performance-metrics">Server Side Performance Metrics</a></li>
</ul></li>
<li><a href="#part-2">Part 2</a></li>
</ul></li>
<li><a href="#interactioncommunication">Interaction/Communication</a></li>
<li><a href="#state">State</a></li>
<li><a href="#logic">Logic</a></li>
<li><a href="#deploymentinfrastructure">Deployment/Infrastructure</a></li>
<li><a href="#security-and-privacy">Security and Privacy</a></li>
<li><a href="#devops">DevOps</a></li>
</ul>
</nav>
<h1 id="architectures-for-distributed-internet-services">Architectures for Distributed Internet Services</h1>
<p>This is my summary for the lecture “Architectures for Distributed Internet Services”, as held by Franz Hauck and Benjamin Erb in 2022 at Ulm University.</p>
<p>The HTML version of this summary can be found at <a href="https://ottojo.github.io/ADIS_Summary/">https://ottojo.github.io/ADIS_Summary/</a>, the sources are on GitHub at <a href="https://github.com/ottojo/ADIS_Summary">https://github.com/ottojo/ADIS_Summary</a>.</p>
<h1 id="static-web-content">Static Web Content</h1>
<h2 id="web-servers">Web Servers</h2>
<ul>
<li>HTTP endpoint which exposes HTTP endpoints</li>
<li>Typical tasks:
<ul>
<li>Request parsing</li>
<li>URI resolving</li>
<li>Responding with appropriate content</li>
</ul></li>
<li>Content often provided by external components</li>
<li>Offers SSL/TLS termination</li>
<li>Might provide access control</li>
<li>Might provide caching</li>
</ul>
<h3 id="static-content">Static Content</h3>
<ul>
<li>This represents a large amount of web resources</li>
<li>Examples:
<ul>
<li>Immutable content (images, videos, static pages)</li>
<li>Static assets (stylesheets, JS sources)</li>
</ul></li>
<li>Server performance in this case predominantly I/O-bound (both disk and network)</li>
</ul>
<h3 id="architectures">Architectures</h3>
<h4 id="multi-thread-multi-process">multi-thread / multi-process</h4>
<ul>
<li>One dedicated thread for accepting connections</li>
<li>Dedicated thread per connections (spawned by first thread)</li>
<li>Allows multiple concurrent connections</li>
<li>Synchronous, blocking IO may be used</li>
<li>Large number of connections make efficient scheduling challenging</li>
<li>-&gt; C10k Problem: Challenge of handling 10k concurrent connections to a server (early 2000s, now: C1M scale and beyond)</li>
</ul>
<h4 id="solutions-for-the-c10k-problem">Solutions for the C10k Problem</h4>
<ul>
<li>Avoid spawning many processes</li>
<li>Avoid 1:1 mapping between connections and threads</li>
<li>Using asynchronous and non-blocking I/O (reduces number of waiting threads)</li>
</ul>
<h4 id="reactor-pattern">Reactor Pattern</h4>
<ul>
<li>Reactor: single thread with event-loop
<ul>
<li>reacts to IO events from a queue</li>
<li>dispatches events</li>
</ul></li>
<li>Event-specific handlers
<ul>
<li>process events produced by reactor</li>
</ul></li>
<li>Implemented in nginx: One master process + one worker per core</li>
</ul>
<h1 id="dynamic-web-content">Dynamic Web Content</h1>
<h2 id="client-side-dynamicity">Client-side dynamicity</h2>
<ul>
<li>Generated within browser</li>
<li>Related to presentation of content</li>
</ul>
<h2 id="server-side-dynamicity">Server-side dynamicity</h2>
<ul>
<li>automatic updating of static files</li>
<li>webserver delegates requests to external programs
<ul>
<li>e.g. CGI script</li>
</ul></li>
<li>webserver executes scripts internally
<ul>
<li>e.g. php module</li>
</ul></li>
<li>webserver has builtin site-gerneration code
<ul>
<li>tight coupling between webserver and application</li>
</ul></li>
</ul>
<h2 id="creating-dynamic-web-content">Creating dynamic web content</h2>
<ul>
<li>some program takes http requests as input and produces web resources (HTML) as output
<ul>
<li>e.g. java servelet</li>
</ul></li>
<li>code may be embedded into web resource, inserting code output into resource
<ul>
<li>e.g. java server faces, PHP</li>
</ul></li>
</ul>
<h3 id="server-side-includes">Server Side Includes</h3>
<ul>
<li>Directives inserted into HTML</li>
<li>executed by the server, but may delegate to CGI scripts</li>
</ul>
<h3 id="external-programs-cgi">External Programs: CGI</h3>
<ul>
<li>Specifies interaction between webserver and external programs (CGI scripts)</li>
<li>Server spawns new process for each request</li>
<li>HTTP headers passed via env variables</li>
<li>HTTP body passed via stdin</li>
<li>CGI script may produce entire HTTP response, or only essential headers and body (remaining data added by server)</li>
<li>Modules for interacting with CGI webserver exist in programming languages, such as CGI.pm in perl</li>
</ul>
<p>Drawbacks:</p>
<ul>
<li>Process creation may be slow</li>
<li>Script initialization happens on every request</li>
<li>Limited communication channel in stdin/out</li>
</ul>
<h3 id="alternative-fastcgi">Alternative: FastCGI</h3>
<ul>
<li>Binary protocol</li>
<li>via unix socket/named pipe/tcp connection</li>
<li>Script keeps running and processes multiple request</li>
<li>Multiple (remote) FastCGI applications may be running and accessed by single web server
<ul>
<li>allows load balancing</li>
<li>separates web and application server</li>
</ul></li>
</ul>
<h3 id="scgi-simple-common-gateway-interface-alternative-to-fastcgi">SCGI (Simple Common Gateway Interface): Alternative to FastCGI</h3>
<ul>
<li>Simplifies interface: non-binary interface</li>
<li>Easier to implement than FastCGI</li>
</ul>
<h3 id="problems-with-cgi">Problems with CGI</h3>
<ul>
<li>CGI programs often use same security context as web server</li>
<li>Apache allows running CGI scripts as specified user/group</li>
</ul>
<h1 id="server-side-scripting">Server-side Scripting</h1>
<p>Scenario: Static HTML page should be enriched by dynamic content.</p>
<p>Here, inside-out scripting is considered. This means scripts are placed inside HTML document. The script output is inserted at their location in the HTML document.</p>
<p>Execution of the scripts:</p>
<ul>
<li>External script interpreter, spawned by server</li>
<li>Long-ruinning external execution environment
<ul>
<li>Similar benefits to FastCGI vs CGI</li>
<li>Used by PHP for example</li>
</ul></li>
<li>Server-internal script handling</li>
</ul>
<p>Inside-out scripting allows HTML-centric development approach.</p>
<p>Self-processing pages are a pattern for processing form data on the same page it is displayed on. This is done by distinguishing between GET/POST request during script execution.</p>
<h2 id="example-perl">Example: Perl</h2>
<ul>
<li>Approach 1
<ul>
<li>HTML provided in template file with placeholders</li>
<li>Separate script provides content for placeholders</li>
</ul></li>
<li>Approach 2
<ul>
<li>Code directly embedded in HTML with special syntax</li>
<li>Output is inserted in location of script, if requested</li>
</ul></li>
</ul>
<h2 id="example-java">Example: Java</h2>
<ul>
<li>Inside-out scripting approach</li>
<li>Before execution, JSP-to-Java transformation transforms HTML with embedded scripts to Java program (“Servlet”) which outputs entire page, containing static and dynamic content.</li>
<li>Generated Servlet allows ahead-of-time compilation</li>
</ul>
<h2 id="example-php">Example: PHP</h2>
<ul>
<li>Designed for inside-out scripting</li>
<li>Execution environment included in web servers like apache</li>
<li>Includes useful functionality for web-dev (databases, HTTP, etc)</li>
</ul>
<h1 id="data-management-sever-side-state">Data Management: Sever-Side State</h1>
<p>Data is stored both on server and client, and data is exchanged in requests and responses. Examples for client data include:</p>
<ul>
<li>Cached resources</li>
<li>Cookies</li>
<li>JS engine state</li>
</ul>
<p>Server data includes:</p>
<ul>
<li>Application data</li>
<li>Session state</li>
<li>Application state</li>
</ul>
<p>The server holds <em>static</em> resources and <em>dynamic</em> application state. Application state may include:</p>
<ul>
<li>User accounts and preferences</li>
<li>Dynamically generated content
<ul>
<li>recommendations</li>
<li>shopping cart</li>
<li>messages between users</li>
</ul></li>
<li>Cached and aggregated data</li>
</ul>
<p>Aspects of server-side state include:</p>
<ul>
<li>how to interact with the server state</li>
<li>how data is modeled</li>
<li>mutability of data</li>
<li>security</li>
<li>storage duration</li>
<li>access patterns</li>
</ul>
<p>Resulting from those aspects are design choices regarding server-side state:</p>
<h2 id="storage-options">Storage Options</h2>
<p>Options are:</p>
<h3 id="main-memory">main memory</h3>
<ul>
<li>application state
<ul>
<li>program memory (stack + heap)</li>
<li>usually managed by language runtime</li>
</ul></li>
<li>in-memory databases
<ul>
<li>provide access API</li>
<li>may provide guarantees about integrity, consistency, visibility</li>
<li>examples: sqlite (in-memory version), h2, many more</li>
</ul></li>
<li>both easy to use and fast access time</li>
<li>drawbacks:
<ul>
<li>volatility (data loss on process stop/restart, overhead otherwise)</li>
<li>small size</li>
</ul></li>
<li>popular for short lived data with fast access requirements</li>
</ul>
<h3 id="local-storage">local storage</h3>
<ul>
<li>file system (flat files)
<ul>
<li>advantages:
<ul>
<li>easy to use</li>
<li>well supported</li>
<li>persistent</li>
<li>easy to backup</li>
<li>large size</li>
</ul></li>
<li>disadvantages
<ul>
<li>unindexed</li>
<li>unstructures</li>
<li>no guarantees for concurrent writes etc</li>
</ul></li>
<li>popular for simple applications</li>
</ul></li>
<li>databases
<ul>
<li>advantages:
<ul>
<li>data is structured</li>
<li>indexed</li>
<li>allow complex search operations</li>
<li>allow relational data</li>
<li>large size</li>
<li>transaction support -&gt; consistency</li>
<li>usually allow distributed setups</li>
<li>integration with other services through standard interfaces (SQL)</li>
</ul></li>
<li>drawbacks:
<ul>
<li>complex API</li>
<li>complex management and administration</li>
</ul></li>
<li>popular for complex structured application data
<ul>
<li>relational databases like postgresql, sqlite, mariadb</li>
<li>noSQL databases, such as k/v stores, document or graph databases</li>
</ul></li>
</ul></li>
</ul>
<h3 id="remote-storage">remote storage</h3>
<ul>
<li>information systems like CRMs</li>
<li>external web services (database server, remote FS)</li>
</ul>
<h1 id="session-management">Session Management</h1>
<p>Sessions provide state beyond individual HTTP requests. Example uses are multi-step forms, login status or shopping carts.</p>
<p>This requires the server to identify subsequent requests belonging to the same user/session. A session is the list of consecutive actions of an individual user. This is usually implemented by labeling the requests, that label is called <em>Session ID</em> or <em>Session Token</em>. The ID is generated on the server side, and has to be unique and un-guessable (to prevent session hijacking). It is transmitted to the client in the first response, which then includes it in subsequent requests. This allows the server to relate it to the session.</p>
<p>Sessions may end, either explicitly (discarding the session ID on server or client) or by timeout.</p>
<h2 id="url-session-identifiers">URL Session Identifiers</h2>
<p>Also called <em>URL rewriting</em>, this is a technique for handling session IDs. It works by embedding the ID in the URL, which requires the server to rewrite all hyperlinks in the response to include the ID.</p>
<p>Advantages:</p>
<ul>
<li>No client support needed</li>
<li>No additional headers required</li>
<li>No cookies required</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>Security risk: Session ID easily exposed by sharing or logging an URL</li>
<li>Correct rewriting might be difficult</li>
</ul>
<h2 id="cookies">Cookies</h2>
<p>Cookies are small chunks of data (KV pairs) related to one domain, which the client includes for every request to the same domain. Cookies provide a more secure way to attach IDs to session.</p>
<p>The server provides the cookies using <code>Set-Cookie</code> headers, which include the session ID.</p>
<p>The client receives the cookie, saves it and sends it back to the server in subsequent requests using the <code>Cookie</code> header.</p>
<h2 id="session-state">Session State</h2>
<p>Once the server has the possibility to relate requests to sessions, session state can be stored. This session state can be arbitrary, and would usually stored in a database indexed by the session ID.</p>
<p>In principle, the entire state could be stored in a cookie, which eliminates the need for server-side storage but has several drawbacks such as limited size and the possibility for the client to modify the state in unexpected ways.</p>
<h2 id="securtity">Securtity</h2>
<p>There are multiple security considerations regarding sessions, in particular Leaking the ID, which can lead to session hijacking and thus impersonating the user</p>
<h1 id="client-side-developments">Client-side Developments</h1>
<p>The desire for more dynamic user interfaces in the web go beyond static HTML pages delivered from the server, and interactions consisting mainly of navigating to different pages. This requires computation on the client-side, which is possible using javascript. Today, the client-side of a web page consist of multiple elements of</p>
<ul>
<li>HTML, defining the content and structure of the page</li>
<li>CSS, providing styling and display information</li>
<li>JavaScript, providing interaction and defining the dynamic behavior</li>
</ul>
<p>The JS execution model of a browser consists of an event loop processing callbacks. Inside the callbacks, the JS code has access to multiple APIs, such as for reading and modifying the DOM, setting timers or making (AJAX) requests.</p>
<h1 id="object-relational-mapping">Object-Relational Mapping</h1>
<p>Traditionally, relational DBs are accessed using SQL statements. Drawbacks to this are that SQL is both a different programming model to the application language and a different data model (relational vs e.g. variables, object oriented). This requires mapping between those two domains, and to synchronously maintain both models, the application code and database.</p>
<p>An idea to solve this is to specify the model only in the application programming language. Data entities could be represented by language objects, relationships by references between objects. The mapping to the DB data model is automatic. Database queries/updates are hidden behind read/write of an object or its properties. Database inserts are hidden behind object creation. Executing queries instantiates language objects (queries themselves still exist).</p>
<p>The database still requires a data model, and schema. This could however automatically be generated from the data model definition in the application language, and may even automatically synchronize changes in the data model.</p>
<h1 id="structured-developments">Structured Developments</h1>
<p>All web developments covered up to this lecture required lots of boilerplate code, which is error prone and causes a high development overhead. This created a demand for a more structured development environment, which includes:</p>
<ul>
<li>Structure and best practices</li>
<li>Common patterns for useful abstractions</li>
<li>Automation of common tasks</li>
</ul>
<p>Those demands ultimately resulted in entire new frameworks for web development.</p>
<h2 id="mvc">MVC</h2>
<p>Model-View-Controller is an architectural pattern applied to web-based services. It separates the application into three independent components:</p>
<ul>
<li>Model
<ul>
<li>Represents data</li>
</ul></li>
<li>View
<ul>
<li>Obtains data from the model in some way</li>
<li>Presents data to the user</li>
</ul></li>
<li>Controller
<ul>
<li>Handles user interaction</li>
<li>Performs operation on data</li>
<li>Controls views, such as activating a new view</li>
</ul></li>
</ul>
<p>The business logic may be located in either the controller or model. If the logic is combined with the data in the model, operations would still be invoked by the controller.</p>
<p>MVC can be applied to web applications in multiple ways:</p>
<h4 id="server-side-mvc">Server Side MVC</h4>
<ul>
<li>All components contained in the server (e.g. CGI script)</li>
<li>Input request handled by controller</li>
<li>Response generated by view</li>
</ul>
<p>Technologies such as Java Servlets assist in extracting the model, but controller and view would still be tightly coupled. Java Server Faces provides a generic, configurable controller component and allow separating the view (“Facelet”). The view can be implemented declaratively as an HTML page containing references to the model.</p>
<p>Django takes a different approach: Django separates the tasks in the components view, model and template. The view handles the request and contains the business logic (like the controller in other examples). The template corresponds to the view in the java example: It is an HTML template which gets instantiated with model data by the view.</p>
<h3 id="summary">Summary</h3>
<ul>
<li>MVC allows modularization, and separates design from programming</li>
<li>Frameworks reduce required boilerplate code by providing common components</li>
<li>Templating for views simplify development</li>
<li>Modularization leads to improved testability</li>
</ul>
<h2 id="some-more-structural-patterns">Some more structural patterns</h2>
<h3 id="inversion-of-control-ioc">Inversion of Control (IoC)</h3>
<p>This principle states that the application code is <em>reactive</em>, not active: it gets called by the framework when relevant events occur, instead of being the main entrypoint into the application.</p>
<h3 id="dont-repeat-yourself">Don’t Repeat Yourself</h3>
<p>Self explanatory</p>
<h3 id="convention-over-configuration">Convention Over Configuration</h3>
<p>Code, configuration and other aspects such as directory structure should be derived from convention whenever possible.</p>
<h3 id="structured-project-directories">Structured Project Directories</h3>
<ul>
<li>Frameworks usually have conventions, an it’s useful to adhere to them</li>
<li>Frameworks sometimes provide generation of project scaffolding (Django, Ruby on Rails)</li>
</ul>
<h1 id="ria-and-spa">RIA and SPA</h1>
<h2 id="thin-vs.-thick-clients">Thin vs. Thick Clients</h2>
<p>In thin-client applications, the browser only handles inputs and renders responses from the server. Interactions between client and server are HTTP requests.</p>
<p>Thick-client applications move some business logic to the client side. This typically allows for improvements in user experience. Some actions are executed locally without server interaction. Other interactions with the server might be application specific, once the client application is loaded.</p>
<h2 id="rich-internet-applications-ria">Rich Internet Applications (RIA)</h2>
<p>Basic idea: Resemble user experience of local desktop application. This requires running some logic on the client side. An extreme example would be a client side game engine running in the browser. RIAs allow platform independence, which might be an advantage compared to native applications.</p>
<p>Examples of RIAs:</p>
<ul>
<li>Google Docs</li>
<li>Web mail clients</li>
<li>Flash games</li>
</ul>
<p>Frameworks are available for both client- and server-side programming.</p>
<p>Today, RIA are “rich web applications”, using native web technologies such as HTML(5), CSS and JS.</p>
<h2 id="single-page-applications-spa">Single Page Applications (SPA)</h2>
<p>SPAs are thick clients, using current web technologies (HTML5, CSS3) and modern web APIs using JS. The page is loaded only once, and the application dynamically modifies the current page based on user input, instead of loading new pages. Interaction with the server is done in the background.</p>
<p>Technologies used:</p>
<ul>
<li>Communication
<ul>
<li>Regular HTTP request for initial load</li>
<li>AJAX/fetch, server-push or WS for later communication</li>
</ul></li>
<li>Data formats
<ul>
<li>JSON and XML for structured data</li>
<li>Alternative: pre-generated HTML from the server</li>
</ul></li>
</ul>
<p>Challenges include:</p>
<ul>
<li>Slow initial loading time</li>
<li>Programmatic access e.g. for search engines</li>
<li>Handling of application state vs page location</li>
<li>Partitioning of logic between client and server</li>
</ul>
<h1 id="node.js-and-unification-of-languages">Node.js and Unification of Languages</h1>
<h2 id="emerging-challenges">Emerging Challenges</h2>
<ul>
<li>Scalability: C10k-like problems for dynamic content</li>
<li>Coordination between server and client, with many clients</li>
<li>Interaction between concurrent requests</li>
<li>Near-real-time information distribution</li>
</ul>
<p>A traditional web application usually features</p>
<ul>
<li>Isolation of individual requests at the server</li>
<li>Application state exclusively in database</li>
</ul>
<p>while a modern application wants to use techniques such as long polling, wherein the server delays a response until some event has occurred (such as a new chat message being sent). This requires a new programming model with</p>
<ul>
<li>Explicit concurrency support (inter-request interactions)</li>
<li>Support for long-running and event-triggered requests</li>
<li>Scalability for dynamic content generation</li>
</ul>
<h2 id="event-driven-web-application-runtime">Event-driven Web Application Runtime</h2>
<p>This model extends the <a href="#reactor-pattern">reactor pattern</a> by allowing the event loop to execute arbitrary application code such as making database queries and generating HTML output.</p>
<h2 id="node.js">Node.js</h2>
<ul>
<li>Asynchronous, event-driven JS runtime</li>
<li>JS is used because it does not have a threading model or standard IO functionality, as all those are provided exclusively by the runtime</li>
<li>Extensive use of callbacks</li>
<li>Framework <code>express</code> simplifies HTTP server creation</li>
<li>All callbacks executed sequentially</li>
<li><code>events</code> library provides inter-request interaction</li>
<li><code>npm</code> package manager and package registry</li>
</ul>
<h2 id="unification-of-languages">Unification of Languages</h2>
<p>Using the same programming language for client and server has many advantages, such as easier debugging and less duplication of server and client code.</p>
<p>A full JS stack has the advantage of not requiring transpilation or code generation for the client side. Also, developers might already be familiar with JS because of its prominence for frontend code.</p>
<p>Popular JS stack “MEAN”: MongoDB, Express, AngularJS, Node.js.</p>
<h1 id="component-based-frameworks">Component-based Frameworks</h1>
<p>This focuses on web component for the client side.</p>
<ul>
<li>Components are reusable view elements, which is desirable to avoid re-implementing features</li>
<li>No standard way for re-using HTML blocks, templating</li>
</ul>
<h2 id="web-components-specification">Web Components Specification</h2>
<ul>
<li>Standardized 2012</li>
</ul>
<p>Building blocks:</p>
<ul>
<li>Custom Elements API: Custom DOM elements
<ul>
<li>associated JS class for behavior</li>
<li>callbacks for insertion, removal etc</li>
</ul></li>
<li>Shadow DOM: Scoped DOM, encapsulating style + markup
<ul>
<li>hides implementation of components</li>
<li>page styles not applied to shadow dom, shadow dom styles not applied on page level</li>
</ul></li>
<li>HTML Templates: Declare HTML fragments, instantiate at runtime
<ul>
<li><code>&lt;slot&gt;</code> allows injection of instance specific data</li>
</ul></li>
<li>ES Modules: reuse of JS documents</li>
</ul>
<h2 id="component-based-application-frameworks">Component-based Application Frameworks</h2>
<p>Those don’t use the standard components directly, but implement similar concepts.</p>
<ul>
<li>Angular
<ul>
<li>Declarative HTML templates</li>
<li>Typescript for defining components, which references HTML and CSS</li>
<li></li>
</ul></li>
<li>React
<ul>
<li>JSX templates: functional instead of declarative</li>
<li>components as state machines</li>
<li>no scoped styles</li>
</ul></li>
<li>Vue.js
<ul>
<li>Declarative HTML templates</li>
</ul></li>
</ul>
<p>Standard Components vs Frameworks:</p>
<ul>
<li>Component support is builtin to browsers</li>
<li>Frameworks often more feature-rich</li>
<li>Frameworks provide virtual DOM</li>
<li>Some frameworks allow export to web components</li>
</ul>
<h1 id="progressive-web-applications">Progressive Web Applications</h1>
<p>Principles of PWAs:</p>
<ul>
<li>discoverable: indexable by search engines</li>
<li>installable: integrates with platform app-launcher/homescreen/whatever</li>
<li>linkable: sharing via URI</li>
<li>network independent: PWA can work offline or with limited connectivity</li>
<li>progressive: basic feature set for old browser, extended features for new browsers
<ul>
<li>graceful degradation: mitigation techniques for missing features</li>
<li>shims, polyfills: re-implementation of modern web APIs for browsers without native support in plain JS</li>
<li>progressive enhancements: opposite of graceful degradation: upgrade basic functionality if available</li>
<li>transpilation of modern JS to version compatible with older browser version</li>
</ul></li>
<li>re-engageable: can send notifications to users</li>
<li>responsive: adapts to device and screen size</li>
<li>safe: secure communication, protection of sensitive data</li>
</ul>
<p>Implementing PWAs:</p>
<ul>
<li>secure contexts
<ul>
<li>browser allows access to sensitive APIs only if requirements fulfilled</li>
<li>requirements might be e.g. a secure connection</li>
</ul></li>
<li>web app manifests
<ul>
<li>declares information about web app such as
<ul>
<li>homescreen icons</li>
<li>appearance options such as full-screen mode</li>
<li>screen orientation</li>
<li>system colors</li>
</ul></li>
<li>referenced by link from HTML header</li>
</ul></li>
<li>service workers
<ul>
<li>proxy between application and network</li>
<li>implements:
<ul>
<li>offline support</li>
<li>cache control</li>
<li>pre-fetching resources</li>
<li>background tasks such as data sync, push notifications</li>
</ul></li>
<li>fully asynchronous</li>
<li>only available in secure context</li>
</ul></li>
</ul>
<h1 id="popular-implementations">Popular Implementations</h1>
<p>This section has been skipped due to an unbearable amount of Java EE content.</p>
<h1 id="introduction-to-scalability">Introduction to Scalability</h1>
<h2 id="part-1">Part 1</h2>
<p>The main requirements for a large scale web application are</p>
<ul>
<li>reliability</li>
<li>scalability</li>
<li>maintainability</li>
</ul>
<p>A scalable system is able to cope with varying load. This might require utilizing additional resources, or graceful degradation in case of temporary overload. Scalability is not the same as performance, as a system which has good performance for a single user it might still not scale well for large numbers of users.</p>
<h3 id="client-side-performance-metrics">Client Side Performance Metrics</h3>
<ul>
<li>DNS lookup time</li>
<li>Time to first byte TTFB</li>
<li>Time to first contentful paint (FCP)</li>
<li>Time to start render</li>
<li>Time to interactive (TTI)</li>
</ul>
<h3 id="server-side-performance-metrics">Server Side Performance Metrics</h3>
<ul>
<li>request throughput (requests per second)</li>
<li>response times (time between receiving request and responding)</li>
<li>hardware utilization</li>
<li>availability</li>
<li>uptime</li>
</ul>
<h4 id="response-times">Response Times</h4>
<p>Both average and peak response time can be measured.. However, those statistics are of limited relevance, since the distribution is usually not normal or uniform. A better way of assessing response times are percentiles (99% of all responses arrive within <span class="math inline">\(p_{99}\)</span>). Percentile plots (hockey stick plots) allow comparing response times of multiple systems.</p>
<h4 id="throughput-vs-response-time">Throughput vs Response Time</h4>
<p>Under load, increased throughput negatively affects response times. This might be due to requests being queued for example.</p>
<h2 id="part-2">Part 2</h2>
<p>(TODO)</p>
<h1 id="interactioncommunication">Interaction/Communication</h1>
<h1 id="state">State</h1>
<h1 id="logic">Logic</h1>
<h1 id="deploymentinfrastructure">Deployment/Infrastructure</h1>
<h1 id="security-and-privacy">Security and Privacy</h1>
<h1 id="devops">DevOps</h1>
</body>
</html>
